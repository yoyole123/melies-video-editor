{
  "version": 3,
  "sources": ["../../src/api/handler.ts", "../../src/shared/security.ts", "../../src/shared/timeline.ts"],
  "sourcesContent": ["import { randomUUID } from 'node:crypto';\r\nimport { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';\r\nimport { DynamoDBClient } from '@aws-sdk/client-dynamodb';\r\nimport { DynamoDBDocumentClient, GetCommand, PutCommand, UpdateCommand } from '@aws-sdk/lib-dynamodb';\r\nimport { SQSClient, SendMessageCommand } from '@aws-sdk/client-sqs';\r\nimport { getSignedUrl } from '@aws-sdk/s3-request-presigner';\r\nimport type { APIGatewayProxyEventV2, APIGatewayProxyStructuredResultV2 } from 'aws-lambda';\r\n\r\nimport { assertValidSignature } from '../shared/security';\r\nimport { getEditorData } from '../shared/timeline';\r\n\r\nconst s3 = new S3Client({});\r\nconst ddb = DynamoDBDocumentClient.from(new DynamoDBClient({}));\r\nconst sqs = new SQSClient({});\r\n\r\nconst ASSETS_BUCKET = process.env.ASSETS_BUCKET ?? '';\r\nconst EXPORTS_BUCKET = process.env.EXPORTS_BUCKET ?? '';\r\nconst JOBS_TABLE = process.env.JOBS_TABLE ?? '';\r\nconst QUEUE_URL = process.env.QUEUE_URL ?? '';\r\nconst SIGNING_SECRET_ARN = process.env.SIGNING_SECRET_ARN ?? '';\r\n\r\nconst SIGNING_MAX_SKEW_SECONDS = Number(process.env.SIGNING_MAX_SKEW_SECONDS ?? 300);\r\nconst PRESIGN_UPLOAD_EXPIRES_SECONDS = Number(process.env.PRESIGN_UPLOAD_EXPIRES_SECONDS ?? 900);\r\nconst PRESIGN_DOWNLOAD_EXPIRES_SECONDS = Number(process.env.PRESIGN_DOWNLOAD_EXPIRES_SECONDS ?? 900);\r\nconst JOB_TTL_SECONDS = Number(process.env.JOB_TTL_SECONDS ?? 7 * 24 * 60 * 60);\r\n\r\nfunction json(statusCode: number, body: unknown): APIGatewayProxyStructuredResultV2 {\r\n  return {\r\n    statusCode,\r\n    headers: {\r\n      'content-type': 'application/json; charset=utf-8',\r\n      'cache-control': 'no-store',\r\n    },\r\n    body: JSON.stringify(body),\r\n  };\r\n}\r\n\r\n/**\r\n * Reads the event body as a UTF-8 string.\r\n */\r\nfunction getRawBody(event: APIGatewayProxyEventV2): string {\r\n  const body = event.body ?? '';\r\n  if (!body) return '';\r\n  if (!event.isBase64Encoded) return body;\r\n  return Buffer.from(body, 'base64').toString('utf8');\r\n}\r\n\r\n/**\r\n * Basic env validation so misconfigurations fail loudly.\r\n */\r\nfunction assertEnv() {\r\n  const missing = [\r\n    ['ASSETS_BUCKET', ASSETS_BUCKET],\r\n    ['EXPORTS_BUCKET', EXPORTS_BUCKET],\r\n    ['JOBS_TABLE', JOBS_TABLE],\r\n    ['QUEUE_URL', QUEUE_URL],\r\n    ['SIGNING_SECRET_ARN', SIGNING_SECRET_ARN],\r\n  ].filter(([, v]) => !v);\r\n\r\n  if (missing.length) {\r\n    throw new Error(`Missing env vars: ${missing.map(([k]) => k).join(', ')}`);\r\n  }\r\n}\r\n\r\nfunction requiresSigning(method: string, path: string): boolean {\r\n  // Keep health publicly accessible; everything else is trusted.\r\n  void method;\r\n  return path.startsWith('/export');\r\n}\r\n\r\nasync function requireSignature(event: APIGatewayProxyEventV2): Promise<void> {\r\n  const method = event.requestContext.http.method.toUpperCase();\r\n  const path = event.rawPath;\r\n  if (!requiresSigning(method, path)) return;\r\n\r\n  const timestampHeader = event.headers['x-base44-timestamp'] ?? event.headers['X-Base44-Timestamp'];\r\n  const signatureHeader = event.headers['x-base44-signature'] ?? event.headers['X-Base44-Signature'];\r\n\r\n  await assertValidSignature({\r\n    signingSecretArn: SIGNING_SECRET_ARN,\r\n    timestampHeader,\r\n    signatureHeader,\r\n    method,\r\n    path,\r\n    rawBody: getRawBody(event),\r\n    maxSkewSeconds: SIGNING_MAX_SKEW_SECONDS,\r\n  });\r\n}\r\n\r\ntype PresignRequest = {\r\n  assets: Array<{ src: string; contentType?: string; ext?: string }>;\r\n};\r\n\r\ntype StartExportRequest = {\r\n  timeline: unknown;\r\n  assets: Array<{ src: string; s3Key: string }>;\r\n};\r\n\r\nexport async function handler(event: APIGatewayProxyEventV2): Promise<APIGatewayProxyStructuredResultV2> {\r\n  try {\r\n    assertEnv();\r\n\r\n    const method = event.requestContext.http.method.toUpperCase();\r\n    const path = event.rawPath;\r\n\r\n    if (method === 'GET' && path === '/health') {\r\n      return json(200, { ok: true });\r\n    }\r\n\r\n    await requireSignature(event);\r\n\r\n    if (method === 'POST' && path === '/export/presign') {\r\n      const rawBody = getRawBody(event);\r\n      const parsed = JSON.parse(rawBody || '{}') as PresignRequest;\r\n      const assets = Array.isArray(parsed.assets) ? parsed.assets : [];\r\n\r\n      const uploads = [] as Array<{ src: string; s3Key: string; uploadUrl: string }>;\r\n      for (const asset of assets) {\r\n        const src = String(asset?.src ?? '');\r\n        if (!src) continue;\r\n\r\n        const ext = String(asset?.ext ?? '');\r\n        const safeExt = ext && ext.startsWith('.') && ext.length <= 10 ? ext : '';\r\n\r\n        const s3Key = `assets/${randomUUID()}${safeExt}`;\r\n        const contentType = asset?.contentType ? String(asset.contentType) : 'application/octet-stream';\r\n\r\n        const command = new PutObjectCommand({\r\n          Bucket: ASSETS_BUCKET,\r\n          Key: s3Key,\r\n          ContentType: contentType,\r\n        });\r\n\r\n        const uploadUrl = await getSignedUrl(s3, command, { expiresIn: PRESIGN_UPLOAD_EXPIRES_SECONDS });\r\n        uploads.push({ src, s3Key, uploadUrl });\r\n      }\r\n\r\n      return json(200, { uploads });\r\n    }\r\n\r\n    if (method === 'POST' && path === '/export') {\r\n      const rawBody = getRawBody(event);\r\n      const parsed = JSON.parse(rawBody || '{}') as StartExportRequest;\r\n\r\n      const editorData = getEditorData(parsed.timeline);\r\n\r\n      const assets = Array.isArray(parsed.assets) ? parsed.assets : [];\r\n      const assetsBySrc = new Map<string, string>();\r\n      for (const a of assets) {\r\n        const src = String(a?.src ?? '');\r\n        const s3Key = String(a?.s3Key ?? '');\r\n        if (!src || !s3Key) continue;\r\n        assetsBySrc.set(src, s3Key);\r\n      }\r\n\r\n      // Light validation that timeline references only provided src keys.\r\n      // The worker will enforce this again.\r\n      void editorData;\r\n\r\n      const jobId = randomUUID();\r\n      const now = Date.now();\r\n      const expiresAt = Math.floor((now + JOB_TTL_SECONDS * 1000) / 1000);\r\n\r\n      await ddb.send(\r\n        new PutCommand({\r\n          TableName: JOBS_TABLE,\r\n          Item: {\r\n            jobId,\r\n            status: 'QUEUED',\r\n            createdAt: now,\r\n            updatedAt: now,\r\n            expiresAt,\r\n          },\r\n          ConditionExpression: 'attribute_not_exists(jobId)',\r\n        })\r\n      );\r\n\r\n      await sqs.send(\r\n        new SendMessageCommand({\r\n          QueueUrl: QUEUE_URL,\r\n          MessageBody: JSON.stringify({\r\n            jobId,\r\n            timeline: parsed.timeline,\r\n            assets: [...assetsBySrc.entries()].map(([src, s3Key]) => ({ src, s3Key })),\r\n          }),\r\n        })\r\n      );\r\n\r\n      // Best-effort status update.\r\n      await ddb.send(\r\n        new UpdateCommand({\r\n          TableName: JOBS_TABLE,\r\n          Key: { jobId },\r\n          UpdateExpression: 'SET #s = :s, updatedAt = :u',\r\n          ExpressionAttributeNames: { '#s': 'status' },\r\n          ExpressionAttributeValues: { ':s': 'QUEUED', ':u': Date.now() },\r\n        })\r\n      );\r\n\r\n      return json(200, { jobId });\r\n    }\r\n\r\n    const jobMatch = path.match(/^\\/export\\/(?<jobId>[a-zA-Z0-9-]+)$/);\r\n    if (method === 'GET' && jobMatch?.groups?.jobId) {\r\n      const jobId = jobMatch.groups.jobId;\r\n\r\n      const resp = await ddb.send(\r\n        new GetCommand({\r\n          TableName: JOBS_TABLE,\r\n          Key: { jobId },\r\n        })\r\n      );\r\n\r\n      if (!resp.Item) return json(404, { error: 'Job not found.' });\r\n\r\n      const status = String((resp.Item as any).status ?? 'UNKNOWN');\r\n      const outputKey = (resp.Item as any).outputKey ? String((resp.Item as any).outputKey) : null;\r\n\r\n      let downloadUrl: string | null = null;\r\n      if (status === 'SUCCEEDED' && outputKey) {\r\n        const cmd = new GetObjectCommand({ Bucket: EXPORTS_BUCKET, Key: outputKey });\r\n        downloadUrl = await getSignedUrl(s3, cmd, { expiresIn: PRESIGN_DOWNLOAD_EXPIRES_SECONDS });\r\n      }\r\n\r\n      return json(200, {\r\n        jobId,\r\n        status,\r\n        error: (resp.Item as any).error ?? null,\r\n        outputKey,\r\n        downloadUrl,\r\n      });\r\n    }\r\n\r\n    return json(404, { error: 'Not found.' });\r\n  } catch (err) {\r\n    const message = err instanceof Error ? err.message : String(err);\r\n\r\n    const lower = message.toLowerCase();\r\n    if (lower.includes('signature') || lower.includes('x-base44-timestamp') || lower.includes('timestamp')) {\r\n      return json(401, { error: message });\r\n    }\r\n\r\n    if (lower.startsWith('missing env vars')) {\r\n      return json(500, { error: 'Server misconfiguration.' });\r\n    }\r\n\r\n    // Avoid leaking internals: keep error terse.\r\n    return json(400, { error: message });\r\n  }\r\n}\r\n", "import crypto from 'node:crypto';\r\nimport { SecretsManagerClient, GetSecretValueCommand } from '@aws-sdk/client-secrets-manager';\r\n\r\nconst secretsClient = new SecretsManagerClient({});\r\n\r\nlet cachedSecretPromise: Promise<string> | null = null;\r\n\r\n/**\r\n * Loads the HMAC signing secret from Secrets Manager.\r\n *\r\n * Cached per Lambda execution environment to reduce latency.\r\n */\r\nexport async function getSigningSecret(signingSecretArn: string): Promise<string> {\r\n  if (!cachedSecretPromise) {\r\n    cachedSecretPromise = (async () => {\r\n      const resp = await secretsClient.send(new GetSecretValueCommand({ SecretId: signingSecretArn }));\r\n      const secretString = resp.SecretString ?? '';\r\n      if (!secretString) throw new Error('Signing secret is empty.');\r\n      return secretString;\r\n    })();\r\n  }\r\n  return cachedSecretPromise;\r\n}\r\n\r\n/**\r\n * Computes an HMAC-SHA256 signature for the given message.\r\n */\r\nexport function computeSignatureHex(secret: string, message: string): string {\r\n  return crypto.createHmac('sha256', secret).update(message).digest('hex');\r\n}\r\n\r\n/**\r\n * Constant-time comparison for hex strings.\r\n */\r\nexport function safeEqualHex(a: string, b: string): boolean {\r\n  const aa = Buffer.from(String(a || ''), 'hex');\r\n  const bb = Buffer.from(String(b || ''), 'hex');\r\n  if (aa.length === 0 || bb.length === 0) return false;\r\n  if (aa.length !== bb.length) return false;\r\n  return crypto.timingSafeEqual(aa, bb);\r\n}\r\n\r\n/**\r\n * Validates an incoming request signature.\r\n */\r\nexport async function assertValidSignature(params: {\r\n  signingSecretArn: string;\r\n  timestampHeader: string | undefined;\r\n  signatureHeader: string | undefined;\r\n  method: string;\r\n  path: string;\r\n  rawBody: string;\r\n  maxSkewSeconds: number;\r\n}): Promise<void> {\r\n  const {\r\n    signingSecretArn,\r\n    timestampHeader,\r\n    signatureHeader,\r\n    method,\r\n    path,\r\n    rawBody,\r\n    maxSkewSeconds,\r\n  } = params;\r\n\r\n  if (!timestampHeader || !signatureHeader) {\r\n    throw new Error('Missing request signature headers.');\r\n  }\r\n\r\n  const timestampMs = Number(timestampHeader);\r\n  if (!Number.isFinite(timestampMs)) {\r\n    throw new Error('Invalid x-base44-timestamp.');\r\n  }\r\n\r\n  const nowMs = Date.now();\r\n  const skewSeconds = Math.abs(nowMs - timestampMs) / 1000;\r\n  if (skewSeconds > maxSkewSeconds) {\r\n    throw new Error('Request timestamp is outside the allowed window.');\r\n  }\r\n\r\n  const secret = await getSigningSecret(signingSecretArn);\r\n  const message = `${timestampMs}.${method.toUpperCase()}.${path}.${rawBody}`;\r\n  const expected = computeSignatureHex(secret, message);\r\n\r\n  if (!safeEqualHex(expected, signatureHeader)) {\r\n    throw new Error('Invalid request signature.');\r\n  }\r\n}\r\n", "/**\r\n * Minimal runtime validation for the timeline payload.\r\n */\r\nexport function assertValidTimeline(timeline: unknown): asserts timeline is { editorData: unknown[] } {\r\n  const editorData = (timeline as { editorData?: unknown })?.editorData;\r\n  if (!Array.isArray(editorData)) {\r\n    throw new Error('`timeline.editorData` must be an array.');\r\n  }\r\n}\r\n\r\n/**\r\n * Extracts editorData (array) or throws.\r\n */\r\nexport function getEditorData(timeline: unknown): unknown[] {\r\n  assertValidTimeline(timeline);\r\n  return (timeline as { editorData: unknown[] }).editorData;\r\n}\r\n"],
  "mappings": "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",
  "names": ["handler_exports", "__export", "handler", "__toCommonJS", "import_node_crypto", "import_client_s3", "import_client_dynamodb", "import_lib_dynamodb", "import_client_sqs", "import_s3_request_presigner", "import_node_crypto", "import_client_secrets_manager", "secretsClient", "cachedSecretPromise", "getSigningSecret", "signingSecretArn", "secretString", "computeSignatureHex", "secret", "message", "crypto", "safeEqualHex", "a", "b", "aa", "bb", "assertValidSignature", "params", "timestampHeader", "signatureHeader", "method", "path", "rawBody", "maxSkewSeconds", "timestampMs", "nowMs", "expected", "assertValidTimeline", "timeline", "editorData", "getEditorData", "s3", "ddb", "sqs", "ASSETS_BUCKET", "EXPORTS_BUCKET", "JOBS_TABLE", "QUEUE_URL", "SIGNING_SECRET_ARN", "SIGNING_MAX_SKEW_SECONDS", "PRESIGN_UPLOAD_EXPIRES_SECONDS", "PRESIGN_DOWNLOAD_EXPIRES_SECONDS", "JOB_TTL_SECONDS", "json", "statusCode", "body", "getRawBody", "event", "assertEnv", "missing", "v", "k", "requiresSigning", "method", "path", "requireSignature", "timestampHeader", "signatureHeader", "assertValidSignature", "handler", "rawBody", "parsed", "assets", "uploads", "asset", "src", "ext", "safeExt", "s3Key", "contentType", "command", "uploadUrl", "editorData", "getEditorData", "assetsBySrc", "a", "jobId", "now", "expiresAt", "jobMatch", "resp", "status", "outputKey", "downloadUrl", "cmd", "err", "message", "lower"]
}
